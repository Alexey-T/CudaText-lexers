object SyntAnal19: TLibSyntAnalyzer
  Formats = <
    item
      DisplayName = 'Id'
      Font.Charset = DEFAULT_CHARSET
      Font.Color = clBlack
      Font.Height = -13
      Font.Name = 'Courier New'
      Font.Style = []
    end
    item
      DisplayName = 'Symbol'
      Font.Charset = DEFAULT_CHARSET
      Font.Color = clMaroon
      Font.Height = -13
      Font.Name = 'Courier New'
      Font.Style = [fsBold]
    end
    item
      DisplayName = 'Number'
      Font.Charset = DEFAULT_CHARSET
      Font.Color = clNavy
      Font.Height = -13
      Font.Name = 'Courier New'
      Font.Style = [fsBold]
    end
    item
      DisplayName = 'String'
      Font.Charset = DEFAULT_CHARSET
      Font.Color = clTeal
      Font.Height = -13
      Font.Name = 'Courier New'
      Font.Style = []
    end
    item
      DisplayName = 'Comment'
      Font.Charset = DEFAULT_CHARSET
      Font.Color = clGray
      Font.Height = -13
      Font.Name = 'Courier New'
      Font.Style = [fsItalic]
    end
    item
      DisplayName = 'Id keyword'
      Font.Charset = DEFAULT_CHARSET
      Font.Color = clBlack
      Font.Height = -13
      Font.Name = 'Courier New'
      Font.Style = [fsBold]
    end
    item
      DisplayName = 'Variable'
      Font.Charset = DEFAULT_CHARSET
      Font.Color = clGreen
      Font.Height = -13
      Font.Name = 'Courier New'
      Font.Style = []
    end
    item
      DisplayName = 'String 2'
      Font.Charset = DEFAULT_CHARSET
      Font.Color = clBlue
      Font.Height = -13
      Font.Name = 'Courier New'
      Font.Style = []
    end
    item
      DisplayName = 'String regex'
      Font.Charset = DEFAULT_CHARSET
      Font.Color = clOlive
      Font.Height = -13
      Font.Name = 'Courier New'
      Font.Style = []
    end
    item
      DisplayName = 'Id types'
      Font.Charset = DEFAULT_CHARSET
      Font.Color = clPurple
      Font.Height = -13
      Font.Name = 'Courier New'
      Font.Style = []
    end
    item
      DisplayName = 'Id funcs'
      Font.Charset = DEFAULT_CHARSET
      Font.Color = clNavy
      Font.Height = -13
      Font.Name = 'Courier New'
      Font.Style = []
    end
    item
      DisplayName = 'Comment doc'
      Font.Charset = DEFAULT_CHARSET
      Font.Color = 7768644
      Font.Height = -13
      Font.Name = 'Courier New'
      Font.Style = []
    end
    item
      DisplayName = 'Id modifier'
      Font.Charset = DEFAULT_CHARSET
      Font.Color = clOlive
      Font.Height = -13
      Font.Name = 'Courier New'
      Font.Style = []
    end
    item
      DisplayName = 'Id::Id'
      Font.Charset = DEFAULT_CHARSET
      Font.Color = clBlue
      Font.Height = -13
      Font.Name = 'Courier New'
      Font.Style = []
    end>
  TokenRules = <
    item
      DisplayName = 'Comment multiline'
      StyleName = 'Comment'
      TokenType = 1
      Expression = 
        '(?s)\#`\((\(.*?\)|.)*?\)|'#13#10'(?s)\#`\[(\[.*?\]|.)*?\]|'#13#10'(?s)\#`\{(' +
        '\{.*?\}|.)*?\}|'#13#10'(?s)\#`\<(\<.*?\>|.)*?\>'#13#10
      ColumnFrom = 0
      ColumnTo = 0
    end
    item
      DisplayName = 'Comment doc'
      StyleName = 'Comment doc'
      TokenType = 1
      Expression = '(?s)^=begin\x20\S+$.*?^=end\x20\S+$'
      ColumnFrom = 0
      ColumnTo = 0
    end
    item
      DisplayName = 'Comment line'
      StyleName = 'Comment'
      TokenType = 1
      Expression = '\#.*'
      ColumnFrom = 0
      ColumnTo = 0
    end
    item
      DisplayName = 'Variable'
      StyleName = 'Variable'
      TokenType = 8
      Expression = '[\$@%\\&][!\.]?(\w|'#39'[a-z]|\-[a-z])+ | [@\$%]/?'
      ColumnFrom = 0
      ColumnTo = 0
    end
    item
      DisplayName = 'String Regex subst'
      StyleName = 'String regex'
      TokenType = 4
      Expression = 's/ (\\/|.)+? / (\\/|.)*? / \w* '
      ColumnFrom = 0
      ColumnTo = 0
    end
    item
      DisplayName = 'String Regex'
      StyleName = 'String regex'
      TokenType = 4
      Expression = '\w* / (\\/|.)+? / \w* '
      ColumnFrom = 0
      ColumnTo = 0
    end
    item
      DisplayName = 'Id::Id'
      StyleName = 'Id::Id'
      TokenType = 2
      Expression = '[a-z_][\w'#39'\-]*(::[\w'#39'\-]+)+\b'
      ColumnFrom = 0
      ColumnTo = 0
    end
    item
      DisplayName = 'Id'
      StyleName = 'Id'
      TokenType = 2
      Expression = '[a-z_](\w|'#39'[a-z]|\-[a-z])*'
      ColumnFrom = 0
      ColumnTo = 0
    end
    item
      DisplayName = 'String'
      StyleName = 'String'
      TokenType = 4
      Expression = '"(\\\\|\\"|.)*?("|$)'
      ColumnFrom = 0
      ColumnTo = 0
    end
    item
      DisplayName = 'String 2'
      StyleName = 'String'
      TokenType = 5
      Expression = #39'.*?('#39'|$)'#13#10
      ColumnFrom = 0
      ColumnTo = 0
    end
    item
      DisplayName = 'Integer any base'
      StyleName = 'Number'
      TokenType = 6
      Expression = ':\d+<[\w\.]+>'
      ColumnFrom = 0
      ColumnTo = 0
    end
    item
      DisplayName = 'Symbol {}'
      StyleName = 'Symbol'
      TokenType = 7
      Expression = '[\{\}]'
      ColumnFrom = 0
      ColumnTo = 0
    end
    item
      DisplayName = 'Symbol single'
      StyleName = 'Symbol'
      TokenType = 3
      Expression = '[\(\)\[\]\]&]'
      ColumnFrom = 0
      ColumnTo = 0
    end
    item
      DisplayName = 'Symbol'
      StyleName = 'Symbol'
      TokenType = 3
      Expression = '[/\*,\.;:=<>\+\-\?!\|~!\^]+'
      ColumnFrom = 0
      ColumnTo = 0
    end
    item
      DisplayName = 'Float'
      StyleName = 'Number'
      TokenType = 6
      Expression = '\d+(\.\d+)?e[\+\-]?\d+ i?\b | \d+\.\d+ i?\b'
      ColumnFrom = 0
      ColumnTo = 0
    end
    item
      DisplayName = 'Integer std base'
      StyleName = 'Number'
      TokenType = 6
      Expression = '0x[a-f0-9_]+\b |'#13#10'0o[0-7_]+\b |'#13#10'0b[01_]+\b'
      ColumnFrom = 0
      ColumnTo = 0
    end
    item
      DisplayName = 'Integer'
      StyleName = 'Number'
      TokenType = 6
      Expression = '(0d)?\d[_\d]* i?\b'
      ColumnFrom = 0
      ColumnTo = 0
    end>
  BlockRules = <
    item
      DisplayName = 'Id keywords'
      StyleName = 'Id keyword'
      BlockType = btTagDetect
      ConditionList = <
        item
          TagList.Strings = (
            'class'
            'default'
            'do'
            'does'
            'else'
            'elsif'
            'enum'
            'fail'
            'for'
            'given'
            'grammar'
            'has'
            'if'
            'is'
            'last'
            'loop'
            'method'
            'my'
            'next'
            'orwith'
            'repeat'
            'return'
            'returns'
            'role'
            'sub'
            'submethod'
            'token'
            'try'
            'unless'
            'until'
            'use'
            'when'
            'while'
            'with'
            'without')
          TokenTypes = 4
        end>
      HighlightPos = cpBound
      IgnoreAsParent = False
    end
    item
      DisplayName = 'Id const'
      StyleName = 'Id types'
      BlockType = btTagDetect
      ConditionList = <
        item
          TagList.Strings = (
            'False'
            'Nil'
            'self'
            'True')
          TokenTypes = 4
        end>
      HighlightPos = cpAny
      IgnoreAsParent = False
    end
    item
      DisplayName = 'Id types'
      StyleName = 'Id types'
      BlockType = btTagDetect
      ConditionList = <
        item
          TagList.Strings = (
            'Any'
            'Array'
            'Attribute'
            'Block'
            'Bool'
            'byte'
            'Capture'
            'Code'
            'Cool'
            'Hash'
            'int'
            'Int'
            'int16'
            'int32'
            'int64'
            'int8'
            'List'
            'Map'
            'Method'
            'Mu'
            'Nil'
            'Num'
            'num32'
            'num64'
            'ObjAt'
            'Parameter'
            'Proxy'
            'Rat'
            'Regex'
            'Routine'
            'Scalar'
            'Signature'
            'Slip'
            'Stash'
            'str'
            'Str'
            'Sub'
            'Submethod'
            'uint16'
            'uint32'
            'uint64'
            'uint8')
          TokenTypes = 4
        end>
      HighlightPos = cpAny
      IgnoreAsParent = False
    end
    item
      DisplayName = 'Id funcs'
      StyleName = 'Id funcs'
      BlockType = btTagDetect
      ConditionList = <
        item
          TagList.Strings = (
            'CATCH'
            'chars'
            'defined'
            'denominator'
            'die'
            'dir'
            'e'
            'exit'
            'flip'
            'get'
            'IO'
            'is-prime'
            'keys'
            'kv'
            'lines'
            'map'
            'mkdir'
            'nude'
            'numerator'
            'open'
            'print'
            'prompt'
            'push'
            'reverse'
            'rmdir'
            'run'
            'say'
            'shell'
            'slurp'
            'sort'
            'spurt'
            'uc'
            'unique'
            'values'
            'warn'
            'WHAT')
          TokenTypes = 4
        end>
      HighlightPos = cpAny
      IgnoreAsParent = False
    end
    item
      DisplayName = 'Id func modifiers'
      StyleName = 'Id modifier'
      BlockType = btTagDetect
      ConditionList = <
        item
          TagList.Strings = (
            'constant'
            'multi'
            'only'
            'proto')
          TokenTypes = 4
        end>
      HighlightPos = cpAny
      IgnoreAsParent = False
    end
    item
      DisplayName = 'Tree item'
      ConditionList = <
        item
          TagList.Strings = (
            '{')
          TokenTypes = 128
        end
        item
          CondType = tcSkip
          TokenTypes = 383
        end
        item
          TagList.Strings = (
            'class'
            'method'
            'role'
            'sub'
            'submethod'
            'token')
          TokenTypes = 1028
        end>
      BlockEnd = '}'
      NameFmt = '%sz0'
      RefToCondEnd = True
      HighlightPos = cpAny
      CancelNextRules = True
      DrawStaple = True
      CollapseFmt = '%sz0'
      IgnoreAsParent = False
    end
    item
      DisplayName = '{'
      ConditionList = <
        item
          TagList.Strings = (
            '{')
          TokenTypes = 128
        end>
      BlockEnd = '}'
      DisplayInTree = False
      HighlightPos = cpAny
      DrawStaple = True
      CollapseFmt = '...'
      IgnoreAsParent = False
    end
    item
      DisplayName = '}'
      BlockType = btRangeEnd
      ConditionList = <
        item
          TagList.Strings = (
            '}')
          TokenTypes = 128
        end>
      HighlightPos = cpAny
      IgnoreAsParent = False
    end>
  CodeTemplates = <>
  SubAnalyzers = <>
  SampleText.Strings = (
    '#`['
    'And this is how a multi would work [nested]'
    ']'
    '$n = _test_aal + n-long + with-num12 + don'#39't-do-that'
    'say "Test" + '#39'Test'#39' + Name::NN::MM::DD:'
    '$int = 10_000_000 + 0xB_EF + 0d2_00 + 0o7_70 + 0b10_10'
    '$base = :3<12_01> + :16<A_0>'
    '$float = 1e0 + 6.02e23 + 1e-9 + -2e48'
    '$c = 1+2i + 6.123e5i'
    'True, False, Nil'
    'my %mix is Mix;              # Mix '
    'my %mix-hash is MixHash;     # MixHash'
    '/foo/          # Short version '
    'rx/foo/        # Longer version '
    'Q :regex /foo/ # Even longer version'
    'my $r = /foo/; # Regexes can be assigned to variables'
    ''
    '=begin cmt'
    'Doc comment...'
    '=end cmt'
    ''
    'my class CallFrame {'
    '    has $.annotations;'
    '    has $.my;'
    ''
    
      '    only method new(CallFrame: Int:D $level = 0) {  # MUST BE AN' +
      ' only'
    
      '        nqp::create(CallFrame).SET-SELF(            # wrt to bac' +
      'ktrace levels'
    
      '          nqp::backtrace(nqp::handle(nqp::die('#39#39'),'#39'CATCH'#39',nqp::e' +
      'xception))'
    '        )'
    '    }'
    ''
    '    method line() { nqp::atkey($!annotations,'#39'line'#39') }'
    '    method file() { nqp::atkey($!annotations,'#39'file'#39') }'
    '    multi method gist(CallFrame:D:) {'
    '        nqp::atkey($!annotations,'#39'file'#39')'
    '          ~ '#39' at line '#39
    '          ~ nqp::atkey($!annotations,'#39'line'#39')'
    '    }'
    '}'
    ''
    
      'only sub callframe(Int:D $level = 0) { # MUST BE an only wrt to ' +
      'backtrace levels'
    '    nqp::create(CallFrame).SET-SELF('
    '      $level,'
    
      '      nqp::backtrace(nqp::handle(nqp::die('#39#39'),'#39'CATCH'#39',nqp::excep' +
      'tion))'
    '    )'
    '}')
  TokenTypeNames.Strings = (
    'Unknown'
    'Comment'
    'Id'
    'Symbol'
    'String'
    'String 2'
    'Number'
    'Symbol {}'
    'Var')
  Extentions = 'p6 pm6 pod6'
  LexerName = 'Perl 6'
  Notes.Strings = (
    'Alexey (CudaText)')
  LineComment = '#'
  Charset = DEFAULT_CHARSET
end
